#!/usr/bin/env python
"""
    This is the simple Guider application designed to exercise the control flow to and from the OCS, the GCS and other
    SISPI applications. No attempts are made to implement a guide algorithm. The application interacts with the TCSINTERFACE
    and the GCS if present in the SISPI instance.

    When enabled, the Guide application scans a local directory for 'DONE' files from the guide PAN. The guide algorithm
    analyzes this image looking for stars and reports the results to the telescope control system (via the TCSINTERFACE application).
    Details of this algorithm are not included in this simple model.
    Guide images either include the full 2kx2k guide CCD or smaller postage stamps when ROI information has been loaded to the GCS.

    Different modes of operation are supported

    guide_mode      Function
    auto            On receipt of 'start_guiding' command the guider arms the scan loop and begins to look for 'DONE' files.
                    The guide images are taken as they come from the guider PAN. The guider does not attempt to optimize the
                    region of interest in this mode.
    self            In this mode the guide analyzes the next (first) image and finds the best guide star for each CCD. ROI information
                    is extracted and sent to the GCS. The GCS then issues another start_guider call with the mode changed from 'self'
                    to 'auto'. The guider exposure sequence number will be maintained.
                    stop_guiding is called after the first image.
    user            In this mode a single image is taken, analyzed and presented to the observer. The observer selects the guide star(s)
                    and the guider determines the ROI information which it forwards to the GCS. The internal mode is then changed
                    from 'user' to 'auto'.
                    The (PML) function 'manual_selection' can be used to load ROI settings for the selected star(s) into the GCS
                    stop_guiding is called after the first image.
                    
    The default guide mode is 'auto'. It can be set in the .ini file and dynamically with a set command as well as via the
    prepare_for_exposure command on an exposure by exposure basis.
    Separate configuration variables (not implemented in the simple Guider) control whether the algorithm uses one or more CCD,
    how the corrections are averaged and whether corrections are sent to the TCS or not.

    Normal operation flow chart:
         Initialization -- when the application is started
         Configuration -- called from the OCS during OCS configuration
         [set/get] -- if some default parameters such as the default guide mode have to be adjusted.
         start_guiding/stop_guiding -- starts/stops processing.
                                       Send by the GCS to inform the Guider that a new exposure is about to start.
                                       The application has to acknowledge this within a few seconds (ie until the telescope stops slewing)

    The image files names generated by panview and used by the Guider are defined in the GCS application following this scheme:
    <image_directory>/<image_base_name>_<exposure_number>_<guider_exposure_number>_roi.fits  (and _roi.DONE)
    The image_base_name can include the fpa name but this is not required as long as the directory/filename combination is unique.
    
    Default values for the directory and the base name can be set in the Guider role section in the .ini file. The default values can be changed dynamically
    using set (and get) commands and can be passed as an argument on an image by image basis in the start_guiding call.
"""
from SISPIlib.application import Application
import SISPIlib.discovery as discovery
from SISPIlib.monitor import Monitor
from SISPIlib.exposure import Exposure
import SISPIlib.config
import pyfits
import random
import time
import datetime
import os
import threading
import numpy
import math

class Guider(Application):
    # The default role name
    role = 'GUIDER'
    component = 'GUIDER'
    # Set of defaults, can be accessed through self.config
    defaults = {'mode' : 'auto',                        # Default guide mode
                'send_corrections' : True,              # Flag to control communication with TCS
                "im_dir" : ".",                         # Directory for guider images
                "tmp_dir": "/dev/shm/guider/",          # Directory for guider tmp files
                "im_name" : "Image",                    # Base name for guider images.
                                                        # filename = im_name_<expid>_<index>.fits
                                                        # where index starts from 0 and counts the
                                                        # guide frames in the exposure
                "inform_GCS" : True,                    # Inform GCS is guide mode changes
                'enable_simulation': False,             # Enable simulated images (overwrites acquired)
                'show_testunit': False,                 # Print results in simulation mode
                'remove_temp_files': True,              # Remove processed .fits and .USED/.ERROR files after the guiding loop
                'remove_old_files': True,               # Remove already existing .fits .USED and .DONE before the guiding loop. Files .DONE are renamed .MISSED if False.
                'scale': 0.27,                          # Pixel Scale ("/pix)
                'ccd_size': [2048,2048],                # Detector size (pixels)
                'safe_edge': 'half_roi',                # Distance from the edge of the image where stars are considered safe for guiding (pixels).
                                                        # If 'half_roi' is set, sets the safe range as half of the ROI size (size taken from GCS)
                'search_range': 5.,                     # Radius range where the guide algorithm searches the reference (")
                'flag_cut': 2,                          # SExtractor flag limit to discard detections
                'nCCDs': 4,                             # Number of Guide CCDs
                'max_ccd_errors': 3,                    # Maximum number of ccd errors in a row (guide star not found) before disabling it
                'max_null_centroids': 2,                # Maximum number of void centroids in a row before stopping the guider
                'turbulence_sigma': 0.5,                # Telescope turbulence movement (Gauss sigma in ") (Simulation only)
                'centroid_combination_type': 'WeightedMean',  # CCD centroids combination type (Mean, WeightedMean, Median)
                'discard_options': {'mode' : 'Adaptive','threshold' : 4},  # Discard CCD centroids mode (Disabled/Fix/Adaptive)
                'roi_radius': 50,                       # Region of Interest radius (width is 2x radius +1) (pixels)
                'max_wait_time': 60,                    # Maximum time to be waiting for the requested image (seconds)
                'min_latency_time': 3.0,                # Minimum guide latency time for each iteration (time between TCS correction signals) [0 = Disabled] (seconds)
                'feedback_percentage': 30,              # Percentage of signal sent to TCS
                'roi_default_location': [100,100],      # Default ROI location when CCD is disabled
                'export_centroids_file' : True          # Creates a file with timestamps, all CCD centroids and TCS centroid
                }
    
    # List the commands to be made available externally
    # For this simple version most commands from Santi's Guider have been removed 
    commands = ['set',
                'get',
                'configure',
                'start_guiding',
                'stop_guiding',
                'manual_selection',
                'set_reference_manual']
    
    def init(self):
        # Guider Initialization
        self.constants_version='DEFAULT'
        self.guide_ccds = ['GS1','GS2','GN1','GN2']
        
        # Guider status
        self.shared_guiderstatus = self.shared_variable("GUIDERSTATUS")
        self.shared_guiderstatus.publish()
        self.enable_guiding = threading.Event()

        # Guider summary
        self.summarySV = self.shared_variable("SUMMARY")
        self.summarySV.publish()
        
        # Exposure Number
        self.exposure_sv = self.shared_variable('EXPOSURENUMBER', group = 'EXPOSURE')
        self.exposure_sv.subscribe()
        
        # Check configuration dictionary and look for TCSINTERFACE, GUIDERGUI and GCS
        tcs = SISPIlib.config.required_roles('TCSInterface',self.full_config)
        self.tcs_available = False if len(tcs) == 0 else True
        if not self.tcs_available:
            self.info('TCSInterface not available in this SISPI instance.')
        gcs = SISPIlib.config.required_roles('GCS',self.full_config)
        self.gcs_available = False if len(gcs) == 0 else True
        if not self.gcs_available:
            self.info('GCS not available in this SISPI instance.')
        gui = SISPIlib.config.required_roles('GuiderGUI',self.full_config)
        self.gui_available = False if len(gui) == 0 else True
        if not self.gui_available:
            self.info('Guider GUI not available in this SISPI instance.')
        
        # Setup Monitor to make sure TCSInterface is online
        components = {}
        if self.tcs_available or self.gcs_available or self.gui_available:
            self.monitorLock = threading.RLock()
            self.monitorEvent = threading.Event()
            self.monitorEvent.clear()
            if self.tcs_available:
                components['TCSINTERFACE'] = {'role':'TCSINTERFACE','tag': 'TCSINTERFACE'}
            if self.gcs_available:
                components['GCS'] = {'role':'GCS','tag': 'GCS'}
            if self.gui_available:
                components['GUIDERGUI'] = {'role':'GUIDERGUI','tag': 'GUIDERGUI'}
            self.monitor = Monitor(app = self, components = components, callback = self.monitor_callback)
        
        # Call intial configuration routine
        self._setup_initial_config()
        
        # Publish Shared variables for GUI
        # CCD dictionaries array (distances in pixels)
        self.shared_ccds = []
        for i in range(self.nccds):
            self.shared_ccds.append( self.shared_variable("CCD%d"%i) )
            self.shared_ccds[i].publish()
            # Update first CCD Shared variable for GUI
            self.shared_ccds[i].write(self.CCDs[i])
        # Centroid (in arcseconds)
        self.shared_centroid = self.shared_variable("CENTROID")
        self.shared_centroid.publish()
        # Seeing (in arcseconds)
        self.shared_seeing = self.shared_variable("SEEING")
        self.shared_seeing.publish()
        # Transparency (in %)
        self.shared_transparency = self.shared_variable("TRANSPARENCY")
        self.shared_transparency.publish()
        
        # Update user information
        self.add_interlock_information(interlock = 'SISPI',key = self.role + '_GUIDERSTATUS',
                                       set_condition=['READY', 'ENABLED', 'GUIDING'],
                                       enabled = True)
        
        # make the Guider discoverable
        discovery.discoverable(role = self.role, tag = 'GUIDER', component=self.component)
        # Update status
        self.shared_guiderstatus.write('INITIALIZED')
        self.info("Initialized")
        
        ############### end of init #####################
    
    
    # PUBLIC (PML) Methods
    def get(self, param):
        """
        Returns current value of some of the internal variables.
        Options include: status, constants_version, mode, gerror_matrix,
        nccds, version, roi_radius. search_range, flag_cut, min_latency_time,
        enable_simulation, remove_temp_files, remove_old_files, show_testunit,
        centroid, seeing, transparency, default_mode, default_image_name, image_name,
        expid, default_send_corrections, send_corrections, default_image_dir, image_dir
        """
        parameter = param.strip().lower()
        if parameter == 'status' or parameter == 'state':         # we allow both
            return self.shared_guiderstatus._value
        elif parameter == 'nccds':
            return self.nccds
        elif parameter.startswith('version'):
            return {'product':self.product,'product_version': self.product_version,'sispi_version' : self.sispi_version}
        elif parameter == 'mode':
            return self.guide_mode
        elif parameter == 'roi_radius':
            return self.roi_radius
        elif parameter == 'search_range':
            return self.search_range
        elif parameter == 'flag_cut':
            return self.flag_cut
        elif parameter == 'min_latency_time':
            return self.min_latency_time
        elif parameter == 'enable_simulation':
            return self.enable_simulation
        elif parameter == 'remove_temp_files':
            return self.remove_temp_files
        elif parameter == 'remove_old_files':
            return self.remove_old_files
        elif parameter == 'show_testunit':
            return self.show_testunit
        elif parameter == 'centroid':
            return self.shared_centroid._value
        elif parameter == 'seeing':
            return self.shared_seeing._value
        elif parameter == 'transparency':
            return self.shared_transparency._value
        elif parameter == 'default_mode':
            return self.default_guide_mode
        elif parameter.find('constants') != -1:
            return self.costants_version
        elif parameter == 'default_image_name' or parameter == 'default_im_name':
            return self.default_image_name
        elif parameter == 'image_name' or parameter == 'im_name':
            return self.image_name
        elif parameter == 'default_image_directory' or parameter == 'default_im_dir':
            return self.default_image_directory
        elif parameter == 'image_directory' or parameter == 'im_dir':
            return self.image_directory
        elif parameter == 'tmp_directory' or parameter == 'tmp_dir':
            return self.tmp_directory
        elif parameter.find('default_send_corrections') != -1:
            return self.default_send_corrections
        elif parameter.find('send_corrections') != -1:
            return self.send_corrections
        elif parameter.find('expid') != -1:
            return self.expid
        elif parameter in self.config.keys():
            return self.config[parameter]
        elif parameter == 'tcs_feedback':
            return self.feedback_percentage
        elif parameter == 'export_centroids_file':
            return self.export_centroids_file
        elif param.startswith('monitor'):
            if param == 'monitor':
                return self.monitor.is_set()
            else:
                arg = param.split()[-1]
                return self.monitor.get(arg)
        else:
            return 'FAILED: Invalid option for get command: %s' % str(param)
    
    def set(self, param):
        """
        Dynamically set Guider variables.
        Options include: mode, send_corrections, im_name, im_dir, default_im_name, default_im_dir
        tcs_feedback, enable_simulation, roi_radius
        """
        # break up arguments, replace '=' with ' ' and extract the command
        if param.find('=') != -1:
            param = param.replace('=',' ')
        try:
            command, args = param.split(' ',1)
        except:
            return 'FAILED: Invalid parameter for set command: %s' % repr(param)
        
        cmd = command.strip().lower()
        
        if cmd == 'mode':
            if args.strip().lower() in ['auto', 'self', 'user']:
                if self.default_guide_mode != args:
                    self.default_guide_mode = args
                    if self.gui_available:
                        self.monitor.execute('GUIDERGUI', 'update', '')
                    if self.inform_GCS and self.gcs_available:
                        return self.monitor.execute('GCS', 'set', 'mode=%s' % args)
                return self.SUCCESS
            else:
                return 'FAILED: Invalid guide mode: %s' % args
        elif cmd == 'guimode':
            if args.strip().lower() in ['auto', 'self', 'user']:
                self.default_guide_mode = args
                if self.inform_GCS and self.gcs_available:
                    return self.monitor.execute('GCS', 'set', 'mode=%s' % args)
                return self.SUCCESS
            else:
                return 'FAILED: Invalid guide mode (gui): %s' % args
        elif cmd.find('send_corrections') != -1:
            self.default_send_corrections =  True if args.upper().find('T') != -1 else False
            return self.SUCCESS
        elif cmd.find('image_name') != -1 or cmd.find('im_name') != -1:
            self.image_name = str(args)
            return self.SUCCESS
        elif cmd.find('image_directory') != -1 or cmd.find('im_dir') != -1:
            self.image_directory = str(args)
            return self.SUCCESS
        elif cmd.find('tmp_directory') != -1 or cmd.find('tmp_dir') != -1:
            self.tmp_directory = str(args)
            return self.SUCCESS
        elif cmd == 'roi_radius':
            if self.shared_guiderstatus._value not in ('READY', 'INITIALIZED'):
                rstring = "FAILED: ROI configuration can only be modified in READY or INITIALIZED status"
                self.warn(rstring)
                return rstring
            else:
                self.roi_radius = int(args)
                return self.SUCCESS
        elif cmd == 'enable_simulation':
            self.enable_simulation = True if 'T' in str(args).upper() else False
            return self.SUCCESS
        elif cmd == 'remove_temp_files':
            self.remove_temp_files = True if 'T' in str(args).upper() else False
            return self.SUCCESS
        elif cmd == 'remove_old_files':
            self.remove_old_files = True if 'T' in str(args).upper() else False
            return self.SUCCESS
        elif cmd == 'flag_cut':
            self.flag_cut = int(args)
            return self.SUCCESS
        elif cmd == 'min_latency_time':
            self.min_latency_time = float(args)
            return self.SUCCESS
        elif cmd == 'export_centroids_file':
            self.export_centroids_file = True if 'T' in str(args).upper() else False
            return self.SUCCESS
        elif cmd == 'show_testunit':
            self.show_testunit = True if 'T' in str(args).upper() else False
            return self.SUCCESS
        elif cmd == 'tcs_feedback':
            if self.shared_guiderstatus._value not in ('READY', 'INITIALIZED'):
                rstring = "FAILED: tcs_feedback can only be modified in READY or INITIALIZED status"
                self.warn(rstring)
                return rstring
            else:
                self.feedback_percentage = float(args)
                return self.SUCCESS
        elif cmd == 'nccds':
            self.nccds = int(args)
        elif cmd == 'ccd_config': # (i.e. args = ccd_config='enable,true,0'
            if self.shared_guiderstatus._value != 'READY':
                rstring = "FAILED: CCD state can only be modified in READY status"
                self.warn(rstring)
                return rstring
            else:
                args = args.replace("'", "") # Remove ' symbols (required to pass multiple arguments)
                if len(args.split(',')) != 3:
                    rstring = "FAILED: CCD state command must have exactly 3 arguments"
                    self.warn(rstring)
                    return rstring
                param, value, ccd_id = args.split(',')
                ccd_id = int(ccd_id)
                if param == "enable":
                    if value.lower().find('true') != -1:
                        self.CCDs[ccd_id]['active'] = True
                    else:
                        self.CCDs[ccd_id]['active'] = False
                    # Update shared CCD
                    self.shared_ccds[ccd_id].write(self.CCDs[ccd_id])
                    return self.SUCCESS
                elif param == "select_mode":
                    if value == 'manual':
                        self.CCDs[ccd_id]['select_mode'] = 'manual'
                    elif value == 'auto':
                        self.CCDs[ccd_id]['select_mode'] = 'auto'
                    else:
                        rstring = "FAILED: Invalid CCD selection mode name. Use 'manual' or 'auto'."
                        self.warn(rstring)
                        return rstring
                    # Update shared CCD
                    self.shared_ccds[ccd_id].write(self.CCDs[ccd_id])
                    return self.SUCCESS
                else:
                    rstring = "FAILED: Invalid ccd configuration name: %s" % str(param)
                    self.warn(rstring)
                    return rstring
        else:
            return("FAILED: Invalid argument: %s" % str(param))
    
    def configure(self, constants = None):
        """
        Configure is called by the GCS to move the guider application from
        INITIALIZED or ERRO to READY.
        """
        
        # Reload initial variables
        self._setup_initial_config()
        
        # Do something with constants if necessary
        self.constants_version = constants
        # Wait for monitor event (up to 120 s)
        if self.tcs_available:
            for i in range(12):
                self.monitorEvent.wait(10)
                if self.monitorEvent.is_set():
                    break
                self.info('Waiting for Monitor. Still undiscovered: %s. Still disconnected: %s.' %
                          (','.join(self.monitor.get('undiscovered')), ','.join(self.monitor.get('disconnected'))))
                if self.monitor.is_set():    # Sometimes we miss a callback - need to fix this
                    self.error('Missed monitor callback.')
                    self.monitor_callback(True)
                    break
            if not self.monitor.is_set():
                rString = 'FAILED: System monitor not set'
                self.error(rString)
                self.shared_guiderstatus.write('ERROR')
                return rString

        # Update status
        self.shared_guiderstatus.write('READY')
        if self.gui_available:
            self.info('Trying to configure GUI')
            try:
                retcode = self.monitor.execute('GUIDERGUI','configure','')
            except Exception,e:
                self.error('FAILED: Exception in gui configure: %s' % str(e))
            else:
                self.info('Guider GUI returns: %s' % str(retcode))
        self.info('Configured')
        return self.SUCCESS
    
    def manual_selection(self, args):
        # Manually set the reference guide star
        # args: ccd_id star_id action
        # action can be none, load (into GCS), or start (load into GCS, start_guiding, expose (GCS))
        if type(args) is dict:
            ccd_id = args['ccd_id']
            star_id = args['star_id']
            action = args['action']
        else:
            try:
                ccd_id, star_id, action = args.split()
                ccd_id = int(ccd_id)
                star_id = int(star_id)
                action = action.lower().strip()
            except: 
                rString = "FAILED: Invalid argument format"
                self.error(rString)
                return rString
        
        if action in ['load','start'] and self.gcs_available:
            # calculate region of interst for this ccd and star it.
            self.debug('Generating ROI information')
            roi = {}
            ccd = self.guide_ccds[ccd_id]
            location = [random.random() * 2048.0, random.random() * 4096.0]
            roi[ccd] = location
            if action == 'load':
                retcode = self.monitor('GCS','load_roi',{'mode' : 'auto', 'roi' : roi})
                self.info('ROI send to GCS. Return Code: %s ' % str(retcode))
            else:
                retcode = self.monitor('GCS','expose',{'mode' : 'auto', 'roi' : roi})
                self.info('ROI send to GCS. Expose called. Return code: %s' % str(retcode))
            return retcode
        else:
            self.info('No or invalid action or GCS is not available.')
        return self.SUCCESS
    
    def stop_guiding(self, args=None):
        # Disable guiding loop variable
        self.info("Stop guiding requested")
        # Update Guider status for GUI
        self.shared_guiderstatus.write('READY')
        self.enable_guiding.clear()
        return 'SUCCESS: ' + self.shared_guiderstatus._value
    
    def start_guiding(self, args):
        """
        Typically called by the GCS this functions instructs the Guider to get ready for the next exposure. Guiding is enabled
        and the application starts to scan for DONE files.
        In this routine one also has to construct the expected image file name. This code is missing in the simple version.
        args is a string with two key=value pairs separated by comma. All are optional
        'expid'      = exposure number
        'mode'       = guide mode for next exposure
        'im_name'    = image base name for next exposure
        'im_dir'     = image directory for next exposure
        'send_corrections' = should corrections be sent to the TCSInterface
        
        args can also be passed as a dictionary.
        """
        self.info("Start guiding requested")
        # Default settings
        self.guide_mode = self.default_guide_mode
        self.expid = self.exposure_sv.read()
        self.image_name = self.default_image_name
        
        # Check & build directories structure
        if not os.path.exists(self.tmp_directory):
            os.makedirs(self.tmp_directory)
            
        self.image_directory = self.default_image_directory
        self.send_corrections = self.default_send_corrections
        
        if type(args) is dict:
            if 'mode' in args:
                self.guide_mode = args['mode']
            if 'expid' in args:
                self.expid = args['expid']
            if 'im_name' in args:
                self.image_name = args['im_name']
            if 'im_dir' in args:
                self.image_directory = args['im_dir']
            if 'send_corrections' in args:
                self.send_corrections = args['send_corrections']
        elif type(args) is str:
            for item in args.split(','):
                k,sep,v = item.partition('=')
                if k.lower().strip() == 'expid':
                    try:
                        self.expid = int(v.strip())
                    except:
                        return 'FAILED: Invalid exposure id.'
                elif k.lower().strip() == 'mode':
                    self.guide_mode = v.lower().strip()
                elif k.lower().strip() == 'im_name':
                    self.image_name = v.lower().strip()
                elif k.lower().strip() == 'im_dir':
                    self.image_directory = v.lower().strip()
                elif k.lower().strip() == 'send_corrections':
                    self.send_corrections =  True if v.upper().find('T') != -1 else False
        else:
            return 'FAILED: Invalid parameter type.'
        
        if self.guide_mode not in ['auto', 'self', 'user']:
            return 'FAILED: Invalid guide mode: %s' % str(self.guide_mode)
        
        self.info("Renaming old DONE and roi.DONE files for %s from: %s" % (self.image_name,self.image_directory))
        os.utime(self.image_directory, None)
        for f in os.listdir(self.image_directory):
            if f.endswith(".DONE"):
                if f.find(self.image_name) != -1:
                    filename = os.path.join(self.image_directory, f.replace(".DONE",""))
                    if self.remove_old_files:
                        if os.path.isfile(filename+'.DONE'):
                            os.remove(filename + '.DONE')
                        if os.path.isfile(filename+'.fits'):
                            os.remove(filename + '.fits')
                    else:
                        if os.path.isfile(filename+'.DONE'):
                            os.rename(filename + '.DONE', filename + '.MISSED')
            elif f.endswith(".USED"):
                if f.find(self.image_name) != -1:
                    filename = os.path.join(self.image_directory, f.replace(".USED",""))
                    if self.remove_old_files:
                        if os.path.isfile(filename+'.USED'):
                            os.remove(filename + '.USED')
                        if os.path.isfile(filename+'.fits'):
                            os.remove(filename + '.fits')
                    else:
                        # do nothing
                        pass
        
        # Enable guiding loop variable
        # Use exposure shared variable and default if necessary
        self.info('Using guide mode %s for exposure %d' % (self.guide_mode,self.expid))
        self.shared_guiderstatus.write('ENABLED')
        self.enable_guiding.set()
        
        return 'SUCCESS: ' + self.shared_guiderstatus._value
    
    def set_reference_manual (self, args):
        # Manually set the reference guide star
        # args: ccd_id star_id
        try:
            ccd_id, star_id = args.split()
            ccd_id = int(ccd_id)
            star_id = int(star_id)
        except: 
            self.error("Invalid argument format")
            return -1
            
        if self.CCDs[ccd_id]['original_reference_star'] == 'waiting':
            try:
                self.CCDs[ccd_id]['original_reference_star'] = star_id
                return 0
            except:
                self.error("Could not assign manual reference")
                return -1
        else:
            self.warn("[CCD %d] Reference star not ready to be assigned." %ccd_id)
            return -1
            
    
    
    # PRIVATE Methods
    # Callback for Monitor
    def monitor_callback(self, state):
        """ Callback function for component monitor. """
        if state:
            self.info("Monitor is set.")
            self.monitorEvent.set()
        else:
            self.warn("Monitor is NOT set.")
            self.monitorEvent.clear()
            self.shared_guiderstatus.write('ERROR')
#            self.alarm_alert('GUIDER not ready. Monitor is not set.',id=2000)
    
    def _setup_initial_config(self):
        # Get the working directories
        self.tmp_directory = self.config['tmp_dir']
        # Check & build directories structure
        if not os.path.exists(self.tmp_directory):
            os.makedirs(self.tmp_directory)
        
        self.product_path = os.getenv('GUIDER_DIR')
        os.chdir(self.product_path) # Go to bin path
        
        # Get default image directory and image name and set current values
        self.default_image_directory = self.config['im_dir']
        self.image_directory = self.default_image_directory
        self.default_image_name = self.config['im_name']
        self.image_name = self.default_image_name
        
        
        # Initialize internal variables
        self.default_guide_mode = self.config['mode']
        self.inform_GCS = self.config['inform_GCS']
        self.guide_mode = None
        self.enable_guiding.clear()
        self.default_send_corrections = True if 'T' in str(self.config['send_corrections']).upper() else False
        self.expid = None
        self.true_offset = [0.0, 0.0]      # Only in simulation mode (pixels)
        self.continuous_null_centroids = 0 # Number of continuous null centroids (any ccd has a valid centroid)
        self.roi_radius = self.config['roi_radius']
        self.nccds = self.config['nCCDs']
        self.ccd_size = self.config['ccd_size']
        self.scale = self.config['scale']
        self.feedback_percentage = self.config['feedback_percentage']
        self.search_range = self.config['search_range']
        self.safe_edge = self.config['safe_edge']
        self.discard_options = self.config['discard_options']
        self.centroid_combination_type = self.config['centroid_combination_type']
        self.enable_simulation = True if 'T' in str(self.config['enable_simulation']).upper() else False
        self.remove_temp_files = True if 'T' in str(self.config['remove_temp_files']).upper() else False
        self.remove_old_files = True if 'T' in str(self.config['remove_old_files']).upper() else False
        self.show_testunit = True if 'T' in str(self.config['show_testunit']).upper() else False
        self.max_ccd_errors = self.config['max_ccd_errors']
        self.max_null_centroids = self.config['max_null_centroids']
        self.flag_cut = self.config['flag_cut']
        self.min_latency_time = self.config['min_latency_time']
        self.roi_default_location = self.config['roi_default_location']
        self.tcs_signal = [0.0,0.0]
        self.export_centroids_file = True if 'T' in str(self.config['export_centroids_file']).upper() else False
        self.utshut_timestamp = ''
        self.utfile_timestamp = ''
        self.utguide_timestamp = ''
        
        
        # Build & Initialize CCDs
        self.CCDs = []
        for iCCD in range(self.nccds):
            CCD = {'id': iCCD,
                   'active': True,
                   'runtime_active': True,
                   'select_mode': 'auto',
                   'stars_list': None,
                   'original_reference_star': None,
                   'last_reference_star': None,
                   'available_stars': 0,
                   'centroid': None,
                   'valid_centroid': False,
                   'continuous_errors': 0,
                   'image_path': None,
                   'sim_image_path': None
                   }
            self.CCDs.append(CCD)
            try:
                # Update first CCD Shared variable for GUI
                self.shared_ccds[iCCD].write(self.CCDs[iCCD])
            except:
                """ Shared variables not ready yet (first initialization) """
                pass
    
    
    def main(self):
        """
        Main method for Guider
        Scan for done files. Select the latest and start the guide algorithm.
        """
        self.info("Guider starting. Role: %s" % self.role)
        
        # Remove old DONE files
        self.info("Renaming old DONE and roi.DONE files from: %s" % self.image_directory) 
        os.utime(self.image_directory, None)
        for f in os.listdir(self.image_directory):
            if f.endswith(".DONE"):
                if f.find(self.image_name) != -1:
                    self.debug("Found file %s. Renamed" % f)
                    filename = os.path.join(self.image_directory, f.replace(".DONE",""))
                    if self.remove_old_files:
                        if os.path.isfile(filename+'.DONE'):
                            os.remove(filename+'.DONE')
                        if os.path.isfile(filename+'.fits'):
                            os.remove(filename+'.fits')
                    else:
                        if os.path.isfile(filename+'.DONE'):
                            os.rename(filename+'.DONE', filename+'.MISSED')
        
        # Main event loop
        while not self.shutdown_event.is_set():
            
            # Out of guide inits
            self.enable_guiding.wait(1)
            self.guide_iteration = 0
            wait_notification = True
            do_statistics = False
            temporal_files = []
            # Prepare centroids file if requested
            if self.export_centroids_file and self.enable_guiding.is_set():
                centroids_path = "/usr/remote/user/sispi/guider_centroid_logs/"
                self.debug("Will export centroids file to %s" %centroids_path)
                if not os.path.exists(centroids_path):
                    try:
                        self.debug("Directory does not exist. Making directory...")
                        os.makedirs(centroids_path)
                    except:
                        self.error("Could not create the path to export the centroids file in %s. Option disabled." %centroids_path)
                        self.export_centroids_file = False
                centroids_file_text = "#Timestamps (UTSHUT UTFILE UTGUIDE in UTC ISO format)\tGS1(x,y)\tGS2(x,y)\tGN1(x,y)\tGN2(x,y)\tCombined TCS Signal(x,y) [all centroids in pixels]\n"
            while self.enable_guiding.is_set():
                
                self.debug("Guide iteration %d" %self.guide_iteration)
                
                # Initialize Guiding
                if self.guide_iteration == 0:
                    
                    # Initialize CCDs
                    for CCD in self.CCDs:
                        CCD['stars_list'] = None
                        CCD['runtime_active'] = CCD['active']
                        CCD['available_stars'] = 0
                        CCD['original_reference_star'] = None
                        CCD['last_reference_star'] = None
                        CCD['centroid'] = None
                        CCD['valid_centroid'] = False
                        CCD['continuous_errors'] = 0
                        CCD['image_path'] = None
                        CCD['sim_image_path'] = None
                    
                    # Initialize variables
                    latency_time_start = None
                    print_waiting = True
                    last_exposure_number = None
                    self.continuous_null_centroids = 0
                    self.sequence_statistics = {'x_offset': [],
                                                'y_offset': [],
                                                'flux':{'GS1': [],
                                                        'GS2': [],
                                                        'GN1': [],
                                                        'GN2': []
                                                        },
                                                'transparency': [],
                                                'seeing': [],
                                                'latency': [],
                                                'guider_termination':1
                                                }
                    self.utshut_timestamp = ''
                    self.utfile_timestamp = ''
                    self.utguide_timestamp = ''
                    self.error_array = []   # Testing Unit (Simulation Only)
                    
                    # Initialize safe edge
                    if self.safe_edge == 'half_roi':
                        # Set safe_edge as half_roi
                        roi_size = self.monitor.execute('GCS', 'get', 'roi_size')
                        self.x_safe_range = (roi_size[0] / 2) + 1
                        self.y_safe_range = (roi_size[1] / 2) + 1
                    else:
                        # If not specified set safe range to both axis
                        self.x_safe_range = self.safe_edge
                        self.y_safe_range = self.safe_edge
                    
                if wait_notification == True:
                    self.info("Scanning directory '%s' looking for '%s'" % (self.image_directory,self.image_name))
                
                
                # Waiting for guider images
                filelist = []
                os.utime(self.image_directory, None)
                image_directory_list = os.listdir(self.image_directory)
                image_directory_list_count = len(image_directory_list)
                if image_directory_list_count > 500:
                    if wait_notification == True:
                        self.warn("The image directory is very large (%d files). Consider cleaning it, performance might be affected." %image_directory_list_count)
                
                for f in image_directory_list:
                    if f.endswith('_roi.DONE') and f.startswith(self.image_name):
                        filename = os.path.join(self.image_directory, f.replace(".DONE",""))
                        os.rename(filename+'.DONE', filename+'.USED')
                        filelist.append(filename + '.fits')
                        temporal_files.append(filename + '.fits')
                        temporal_files.append(filename + '.USED')
                
                # Free memory (useful for dirty directories)
                del image_directory_list
                
                # Sort list and only take the latest image file
                if len(filelist) == 0:
                    if wait_notification:
                        self.info('Waiting for guider images.')
                        wait_notification = False
                    time.sleep(0.1)
                    continue
                elif len(filelist) > 1:
                    self.warn('More than one guider image available. Discarding all but the newest.')
                filelist.sort(key=str.lower)
                # The last entry in the (sorted) list is the newest image file (by exposure and guide exposure number)
                next_image_file = filelist[-1]
                if not os.path.isfile(next_image_file):
                    self.error('Invalid filename %s' % str(next_image_file))
                    continue
                wait_notification = True
                
                
                # Replace Panview Images with Guider Simulated
                if self.enable_simulation == True:
                    self.simulate_guide_array(next_image_file)
                
                # Update only in first iterations
                if self.guide_iteration == 0:
                    self.shared_guiderstatus.write('GUIDING')
                
                # Extract exposure number, guider number
                try:
                    exposure_number = int(next_image_file.split('_')[-3])
                    # Handle optional _roi part if Marco's roi masker is running 
                    guider_exposure_number = int(next_image_file.replace('_roi','').split('_')[-1].split('.')[0].split('-')[0])
                    self.guider_exposure_number = guider_exposure_number                   
                    if exposure_number != last_exposure_number:
                        self.info('Now processing images for exposure %d' % exposure_number)
                        last_exposure_number = exposure_number
                except:
                    self.error("Cannot extract exposure number from file %s.fits" % next_image_file)
                    os.rename(next_image_file.replace('.fits', '.USED') , next_image_file.replace('.fits', '.ERROR'))
                    # Update temporal files list
                    temporal_files.remove(next_image_file.replace('.fits', '.USED'))
                    temporal_files.append(next_image_file.replace('.fits', '.ERROR'))
                    continue
                
                # Get ROI time stamps
                self.debug("Extracting time stamps from image %s..." %next_image_file)
                self.utshut_timestamp = pyfits.getval(next_image_file, 'UTSHUT', 0)
		try:
                    self.utfile_timestamp = pyfits.getval(next_image_file, 'UTFILE', 0)
                except Exception, msg:
                    self.warn('Unable to find utfile_timestamp: %s' % msg)
                    self.utfile_timestamp = ''
                self.debug("...timestamp extraction of UTSHUT and UTFILE complete.")
                
                # Make star lists for all Active CCDs
                self.info('Next guiding image: %s' % next_image_file)
                try:
                    for CCD in self.CCDs:
                        if CCD['runtime_active'] == True:
                            # Update image path with multi-extension fits
                            CCD['image_path'] = next_image_file
                            # Analyze image and make stars list
                            self.make_stars_list(CCD, image_name = next_image_file)
                except Exception, msg:
                    self.error('Exception in make_stars_list (Image file: %s). Message: %s' % (next_image_file, str(msg)))
                    continue
                
                
                # Check guide mode and decide how to continue
                
                # Self mode
                if self.guide_mode == 'self':
                    """
                    1. Set reference guide stars
                    2. Deliver ROIs to GCS
                    3. STOP (clear event)
                    """
                    # Set Reference Star
                    for CCD in self.CCDs:
                        if CCD['runtime_active'] == True:
                            self.set_reference_star(CCD)
                    
                    # Deliver ROIs
                    self.deliver_rois_to_GCS()
                    break
                
                
                # User mode
                elif self.guide_mode == 'user':
                    """
                    1. Set reference guide stars
                    2. Overwrite manual reference stars
                    2. Deliver ROIs to GCS
                    4. STOP (clear event)
                    """
                    # Set Reference Star
                    for CCD in self.CCDs:
                        if CCD['runtime_active'] == True:
                            self.set_reference_star(CCD)
                    
                    # Deliver ROIs
                    self.deliver_rois_to_GCS()
                    break
                
                
                # Auto mode (Loop)
                elif self.guide_mode == 'auto':
                    """
                    1. Set/Search reference star
                    2. Guide control
                    3. Compute & Send centroid
                    4. Continue LOOP
                    """
                    # Set / Search reference guide star
                    for CCD in self.CCDs:
                        if CCD['runtime_active'] == True:
                            if self.guide_iteration == 0:
                                self.set_reference_star(CCD)
                            else:
                                self.search_reference_star(CCD)
                    
                    # Guide control
                    rc = self.guide_control()
                    # Refresh Shared CCDs for GUI
                    for CCD in self.CCDs:
                        self.shared_ccds[CCD['id']].write(CCD)
                    
                    # Compute & Send centroid
                    if (self.guide_iteration != 0) and (self.enable_guiding.is_set()):
                        combined_centroid = self.compute_centroid(guide_control_status = rc)
                    
                    # Export centroid to file
                    if (self.export_centroids_file) and (self.guide_iteration != 0) and (combined_centroid != -1):
                        self.utguide_timestamp = "%s" %datetime.datetime.utcnow()
                        self.utguide_timestamp = self.utguide_timestamp.replace(' ', 'T')
                        centroids_file_text += "%s\t%s\t%s\t" %(self.utshut_timestamp, self.utfile_timestamp, self.utguide_timestamp)
                        for CCD in self.CCDs:
                            if (CCD['runtime_active'] == True) and (CCD['valid_centroid'] == True):
                                centroids_file_text += "%f,%f\t" %(CCD['centroid'][0], CCD['centroid'][1])
                            else:
                                 centroids_file_text += "None,None\t"
                        centroids_file_text += "%f,%f\t" %(combined_centroid[0], combined_centroid[1])
                        centroids_file_text += "\n"
                    # Increase loop counter (only in auto mode?)
                    self.guide_iteration += 1
                
                # Invalid mode
                else:
                    self.error('Invalid guide mode: %s. Stopping guider' % self.guide_mode)
                    self.shared_guiderstatus.write('READY')
                    self.enable_guiding.clear()
                    break
                
                # Send correction to TCS
                if self.guide_mode == 'auto':
                    do_statistics = True
                    if (self.send_corrections and (self.enable_guiding.is_set())):
                        self.debug("Sending corrections to TCS")
                        if self.tcs_available:
                            try:
                                # X is -DEC, Y is RA
                                retcode = self.monitor.execute('TCSINTERFACE','guide_corrections',
                                                               'RA=%.2f DEC=%.2f TIME=%s' % (self.tcs_signal[1], -self.tcs_signal[0], self.utshut_timestamp))
                                self.debug('TCS Signal: RA=%.2f DEC=%.2f TIME=%s' % (self.tcs_signal[1], -self.tcs_signal[0], self.utshut_timestamp))
                            except Exception,e:
                                self.error('Exception calling TCSInterface: %s' % str(e))
                            if retcode != 'DONE':
                                self.error("Image %d.%d analyzed. TCSInterface rejects corrections: %s"
                                           % (exposure_number, guider_exposure_number, repr(retcode)))
                            else:
                                self.debug("Corrections sent for image %d.%d." %(exposure_number, guider_exposure_number))
                        else:
                            self.debug("TCS not available. No correction sent.")
                    else:
                        self.debug("Send corrections disabled in Guider. No correction sent.")
                
                
                # Latency time (relevant time between centroid deliveries)
                if (self.guide_iteration != 0) and (latency_time_start is not None):
                    latency_time = time.time() - latency_time_start
                    if latency_time < self.min_latency_time:
                        sleep_time = self.min_latency_time - latency_time
                        self.debug("Minimum guiding latency time set to %.2fs (last iteration was %fs). Sleeping for %.2fs." %(self.min_latency_time, latency_time, sleep_time))
                        time.sleep(sleep_time)
                        self.sequence_statistics['latency'].append(self.min_latency_time)
                    else:
                        self.debug("Guide latency time %.2fs" %latency_time)
                        self.sequence_statistics['latency'].append(latency_time)
                
                # Start time for next iteration
                latency_time_start = time.time()
            
            # Compute sequence statistics post-guiding
            if do_statistics:
                try:
                    self.compute_sequence_statistics()
                except Exception, e:
                    self.error('Exception in compute_sequence_statistics(): %s' % str(e))
            
            # Save the export centroids file
            if self.export_centroids_file and self.guide_iteration != 0:
                centroids_filename = "guider_centroids_%d.dat" %exposure_number
                self.debug("Exporting the centroids file to %s" %centroids_filename)
                # Hardwired path
                centroids_file = open(centroids_path + centroids_filename, 'w')
                centroids_file.write(centroids_file_text)
                centroids_file.close()
                del centroids_file_text
            
            # Remove temporal files if requested
            if self.remove_temp_files:
                try:
                    for temporal_file in temporal_files:
                        self.debug("Removing temporal file %s..." %temporal_file)
                        if os.path.isfile(temporal_file):
                            os.remove(temporal_file)
                except Exception, e:
                    self.error('Exception trying to remove temporary files: %s' % str(e))
    
    def make_stars_list(self,CCD, image_name):
        # Create a stars list from CCD image
        iCCD = CCD['id']
        image_path = os.path.join(self.image_directory, image_name + "[%d]" %iCCD)
        cat_path = os.path.join(self.tmp_directory, image_name.replace(".fits","") + "_ccd%d.cat" %iCCD)
        
        # Call SExtractor
        self.debug("[CCD %d] Running SExtractor..." %iCCD)
        try:
            os.system("sex -c %s '%s' -CATALOG_NAME %s > %s"
                      %(os.path.join(self.product_path, "config/se.conf"),
                        image_path,
                        cat_path,
                        os.path.join(self.tmp_directory, 'sex.temp')))
            
            # Clean SExtractor tmp file
            sex_temp_file = os.path.join(self.tmp_directory, 'sex.temp')
            if os.path.exists(sex_temp_file):
                os.remove( sex_temp_file ) # Remove sex.temp
            self.debug("[CCD %d] ...SExtractor finished." %iCCD)
        except:
            # Stop guiding & exit
            self.halt_guider("[CCD %d] SExtractor error." %iCCD)
            return -1
        if ( not os.path.exists( cat_path ) ):
            # Stop guiding & exit
            self.halt_guider("[CCD %d] Missing SExtractor output" %iCCD)
            return -1
            
        # Initialize object variables
        guidelines = []
        stars_list = []
        CCD['available_stars'] = 0
        
        # Read SExtractor output for CCD i
        guidelines 
        cf = open(cat_path, 'r')
        guidelines = cf.readlines()
        cf.close()
        os.remove(cat_path)  # Remove last CCD catalogue
        
        junk_count = 0
        flag_count = 0
        edge_count = 0
        cr_count = 0
        
        # Loop SE catalogue lines
        for guideline in guidelines:
            if (guideline[0] != "#"):
                
                # Star object structure
                star ={'number': int(guideline.split()[0]),
                       'flux_auto': float(guideline.split()[1]),
                       'fluxerr_auto': float(guideline.split()[2]),
                       'mag_ref': float(guideline.split()[3]),
                       'x_image': float(guideline.split()[4]),
                       'y_image': float(guideline.split()[5]),
                       'fwhm_image': float(guideline.split()[6]),
                       'ellipticity': float(guideline.split()[7]),
                       'flags': int(guideline.split()[8]),
                       'suitable': True,
                       'sn': None
                       }
                if star['fluxerr_auto'] == 0.0:
                    self.debug('Oops, star fluxerr_auto is 0.0')
                    continue
                else:
                    star['sn'] = ( star['flux_auto']/star['fluxerr_auto'] )
                
                # Skip junk objects found by SExtractor
                if (  ( star['flux_auto'] < 0.1) or       # Flux is 0 or negative
                      ( star['fluxerr_auto'] == 0) or     # Flux error is 0
                      ( star['fwhm_image'] > 50) ):       # FWHM larger than 50
                    junk_count += 1
                    continue
                    
                # Check if the star is usefull for guiding
                
                # Check detection Flags
                if star['flags'] < (self.flag_cut + 1):
                    # Check if detection is very close to the border (only with full CCD images, not with ROI stamps)
                    if (self.guide_mode != 'auto' and (
                          star['x_image'] < self.x_safe_range or
                          star['y_image'] < self.y_safe_range or
                          star['x_image'] > (self.ccd_size[0] - self.x_safe_range) or
                          star['y_image'] > (self.ccd_size[1] - self.y_safe_range))):
                        edge_count += 1
                        star['suitable'] = False
                    elif star['ellipticity'] > 0.5:
                        cr_count += 1
                        star['suitable'] = False
                    else:
                        # Star IS suitable for guiding
                        star['suitable'] = True
                        CCD['available_stars'] += 1
                else:
                    # Star is NOT suitable for guiding
                    flag_count += 1
                    star['suitable'] = False
                    
                # Save star to stars list
                stars_list.append(star)
                
        self.debug("[CCD %d] Detected %d available stars" %(iCCD, CCD['available_stars']))
        self.debug("[CCD %d] Rejected detections: %d junk, %d flagged, %d edge, %d cosmics" %(iCCD, junk_count, flag_count, edge_count, cr_count))
        
        # >>> Update CCD
        CCD['stars_list'] = stars_list
        return CCD
    
    def set_reference_star(self, CCD):
        # Set reference guide star from stars list
        iCCD = CCD['id']
        self.debug("[CCD %d] Started guide star set..." %iCCD)
        # List suitable guiding stars
        suitable_stars = []
        for star in CCD['stars_list']:
            if star['suitable'] == True: # Gets only non saturated nor in the border stars
                suitable_stars.append(star)
                
        # Check for available suitable guiding stars
        if len(suitable_stars) == 0:
            self.warn("[CCD %d] No suitable guiding stars to set." %iCCD)
            # Disable current CCD
            CCD['runtime_active'] = False
            return -1
            
        # Sorted list by SN (first element is highest SN star)
        sorted_stars = sorted(suitable_stars, key = lambda k: k['sn'], reverse = True)
        
        
        # AUTO Selection Mode
        if CCD['select_mode'] == 'auto':
            # Verify isolated star
            for star in sorted_stars:
                isolated = True
                closest_dist = 1e5
                for nearby_star in CCD['stars_list']:
                    dist = math.hypot(star['x_image'] - nearby_star['x_image'],
                                      star['y_image'] - nearby_star['y_image'])
                    if dist == 0:
                        # nearby_star is star itself
                        continue
                    elif ( dist < 2*(self.search_range / self.scale) ):
                        # Nearby star is inside the 2x search range
                        # Star not isolated!
                        isolated = False
                        self.warn("[CCD %d] Highest SN star has nearby stars. Skipping to next.." %iCCD)
                        break
                    if dist < closest_dist:
                        # Measure closest distance
                        closest_dist = dist
                if isolated == True:
                    # star is the isolated star with highest SN
                    ref_star = star
                    break
            if isolated == False:
                # No suitable star is isolated
                self.warn("[CCD %d] No suitable and isolated guiding stars to set." %iCCD)
                # Disable current CCD
                CCD['runtime_active'] = False
                return -1
                
            self.debug("[CCD %d] Reference guide star set with SN %.2f" %(iCCD, ref_star['sn']) )
            self.debug('[CCD %d] Closest star to reference at %.2f"' %(iCCD, closest_dist * self.scale) )
            
            
        # MANUAL Selection Mode
        elif CCD['select_mode'] == 'manual':
            # Ensure reference star is empty (used for syncronization)
            CCD['original_reference_star'] = 'waiting'
            # Build stars list for display - temporal (To be built in GUI)
            stars_list_string = "ID\tSN\tmag\tClosest\n"
            for star in sorted_stars:
                closest_dist = 1e5
                for nearby_star in CCD['stars_list']:
                    dist = math.hypot(star['x_image'] - nearby_star['x_image'],
                                      star['y_image'] - nearby_star['y_image'])
                    if dist == 0:
                        # nearby_star is star itself
                        continue
                    if dist < closest_dist:
                        # Measure closest distance
                        closest_dist = dist
                if closest_dist == 1e5:
                    # No star found
                    stars_list_string += "%d\t%.2f\t%.2f\t - \n" %(star['number'], star['sn'], star['mag_ref'])
                else:    
                    stars_list_string += "%d\t%.2f\t%.2f\t%.2f\n" %(star['number'], star['sn'], star['mag_ref'], closest_dist)
                
            self.debug("[CCD %d] Select a star from the list" %iCCD)
            self.debug('Stars list string: %s' % stars_list_string )
            
            # Update shared CCD
            self.CCDs[iCCD] = CCD
            self.shared_ccds[iCCD].write(self.CCDs[iCCD])
            
            # Wait until external PML command is updates 'original_reference_star' with star id 
            while CCD['original_reference_star'] == 'waiting':
                if self.stop_guiding == True:
                    return -1
                time.sleep(0.1)
                
            # Search star ID in sorted stars list
            ref_star = None
            for star in sorted_stars:
                if star['number'] == CCD['original_reference_star']:
                    ref_star = star
                    self.info("[CCD %d] Reference guide star manually set with SN %.2f" %(iCCD, ref_star['sn']) )
                    break
            if ref_star == None:
                # Manual id set not found
                ref_star = sorted_stars[0]
                self.warn("[CCD %d] Star ID not found. Reference star set automatically to highest SN %.2f" %(iCCD, ref_star['sn']))
            
        else:
            self.error("Invalid selection mode name")
            return -1
            
            
        # >>> Update CCD
        # Set CCD reference star
        CCD['original_reference_star'] = ref_star
        # Set last reference star
        CCD['last_reference_star'] = ref_star
        return CCD
    
    def search_reference_star(self, CCD):
        # Search reference guide star from stars list
        iCCD = CCD['id']
        self.debug("[CCD %d] Started guide star search..." %iCCD)
        # Check for available suitable guiding stars
        if CCD['available_stars'] == 0:
            self.warn("[CCD %d] No available stars found." %iCCD)
            CCD['valid_centroid'] = False
            return -1
            
        # Search for stars in the range of the reference star (candidates)
        candidate_stars = []
        for star in CCD['stars_list']:
            if star['suitable'] == False:  # Skip iteration if the star is NOT suitable
                continue
            # Compute euclidean distance
            dist = math.hypot( star['x_image'] - CCD['original_reference_star']['x_image'],
                               star['y_image'] - CCD['original_reference_star']['y_image'])
            if ( dist < (self.search_range / self.scale) ): #save stars id inside distmax
                candidate_stars.append(star)
                
        # Depending on the number of candidates...
        if len(candidate_stars) == 0: # No star found
            self.warn("[CCD %d] Reference star not found in the search range" %iCCD)
            CCD['valid_centroid'] = False
            return -1
        elif len(candidate_stars) == 1: # Just one candidate
            # The candidate is the reference
            candidate = candidate_stars[0]
        elif len(candidate_stars) > 1: # More than one inside the reference range
        # Pick the star with closest flux from the candidates
            best_flux_difference = 1e6
            for star in candidate_stars:
                flux_difference = abs( CCD['last_reference_star']['flux_auto'] - star['flux_auto'] )
                if ( flux_difference < best_flux_difference):
                    best_flux_difference = flux_difference
                    candidate = star
                    
        self.debug("[CCD %d] Reference star found." %iCCD)
        
        # >>> Update CCD
        # Set last reference star
        CCD['last_reference_star'] = candidate
        # Compute CCD centroid
        CCD['centroid'] = [CCD['original_reference_star']['x_image'] - candidate['x_image'] ,
                           CCD['original_reference_star']['y_image'] - candidate['y_image'] ]
        CCD['valid_centroid'] = True
        return CCD
    
    def deliver_rois_to_GCS(self):
        # Build ROI set
        self.debug("Deliver ROIs to GCS...")
        roi_set = {}
        for CCD in self.CCDs:
            ccd_id = self.guide_ccds[CCD['id']]
            if CCD['runtime_active'] == True:
                # Set guide star location
                location = [CCD['original_reference_star']['x_image'], CCD['original_reference_star']['y_image']]
                roi_set[ccd_id] = location
            else:
                # Set default location
                location = [self.roi_default_location[0], self.roi_default_location[1]]
                roi_set[ccd_id] = location
        
        # Send ROIs to GCS
        if self.gcs_available:
            self.shared_guiderstatus.write('READY')
            self.enable_guiding.clear()
            guider_exposure_number = self.guider_exposure_number
            retcode = self.monitor.execute('GCS',
                                           'update_exposure',
                                           {'mode' : 'auto',
                                            'start_guider' : True,
                                            'guider_expid' : guider_exposure_number + 1,
                                            'roi' : roi_set})
            self.info('Sending ROI information to GCS. Return code: %s' % str(retcode))
        else:
            self.info('Ready to send ROI information but GCS is not available.')
        
    
    def compute_centroid(self, guide_control_status):
        self.debug("Computing centroids...")
        # Compute the combined centroid and send correction to the TCS
        combined_centroid = [0,0]
        
        # If no valid centroid, just send 0,0 correction
        if guide_control_status == 'continue':
            self.debug("There are still active CCDs but no one found a centroid. Sending a (0,0) centroid signal..")
            centroid_dict = {'measured': combined_centroid,
                             'tcssignal': combined_centroid}
            self.shared_centroid.write(centroid_dict)
            return combined_centroid
        
        # Discard discording centroids
        if self.discard_options['mode'] != 'Disabled':
            available_centroids = []
            available_centroids_CCDid = []
            # Add all centroids from active CCDs
            for CCD in self.CCDs:
                if ( (CCD['runtime_active'] == True) and (CCD['valid_centroid'] == True) ):
                    available_centroids.append(CCD['centroid'])
                    available_centroids_CCDid.append(CCD['id'])
                    
            while len(available_centroids) > 2:
                # Build distances matrix
                distance_matrix = numpy.zeros( [len(available_centroids), len(available_centroids)] )
                distance_array = []
                for i in range(len(available_centroids)):
                    for j in range(len(available_centroids)):
                        if j > i:
                            distance = math.hypot(available_centroids[i][0] - available_centroids[j][0],
                                                  available_centroids[i][1] - available_centroids[j][1])
                            distance_matrix[i][j] = distance
                            distance_array.append(distance)
                            
                # Set discordance threshold (in pixels)
                if self.discard_options['mode'] == 'Fix':  # Threshold specified by user directly in "
                    discordance_threshold = self.discard_options['threshold'] / self.scale
                elif self.discard_options['mode'] == 'Adaptive':   # Threshold is minimum distance * X specified
                    discordance_threshold = numpy.min(distance_array) * self.discard_options['threshold']
                else:
                    # Stop guiding & exit
                    self.halt_guider("Invalid discard mode name")
                    return -1
                    
                # Verify if all centroids are inside threshold
                if max(distance_array) > discordance_threshold:
                    # Centroid exceeded threshold - Remove centroid that minimizes the distance between the rest
                    others_distance = []
                    for index in range( len(available_centroids) ):
                        # Remove row and column of index
                        others_matrix = numpy.delete( numpy.delete(distance_matrix, index, axis=0), index, axis=1 )
                        # Sum the distances of the rest
                        others_distance.append(others_matrix.sum())
                        
                    # Remove the one that minimizes the distance of the rest
                    discard_index = others_distance.index( min(others_distance) )
                    discard_CCDid = available_centroids_CCDid[discard_index]
                    for CCD in self.CCDs:
                        if CCD['runtime_active'] == True:
                            if CCD['id'] == discard_CCDid:
                                self.CCDs[ self.CCDs.index(CCD)]['valid_centroid'] = False
                                self.debug("[CCD %d] Centroid discarded." %CCD['id'] +
                                          " Threshold: %.5f  Current: %.5f" %(discordance_threshold,
                                                                              max(distance_array) ) )
                                                                              
                    # Remove centroids and continue
                    available_centroids.pop(discard_index)
                    available_centroids_CCDid.pop(discard_index)
                    
                else:
                    # All centroids inside limits
                    break
                    
                    
        # Combine all available centroids
        if self.centroid_combination_type == "Mean":
            n_valid_centroids = 0
            for CCD in self.CCDs:
                # Only average active CCDs with valid centroids
                if ( (CCD['runtime_active'] == True) and (CCD['valid_centroid'] == True) ):
                    combined_centroid[0] += CCD['centroid'][0]
                    combined_centroid[1] += CCD['centroid'][1]
                    n_valid_centroids += 1
            if n_valid_centroids != 0:
                combined_centroid[0] = combined_centroid[0] / n_valid_centroids
                combined_centroid[1] = combined_centroid[1] / n_valid_centroids
            
        elif self.centroid_combination_type == "WeightedMean":
            denominator = 0
            for CCD in self.CCDs:
                # Only average active CCDs with valid centroids
                if ( (CCD['runtime_active'] == True) and (CCD['valid_centroid'] == True) ):
                    combined_centroid[0] += CCD['centroid'][0] * CCD['last_reference_star']['sn']
                    combined_centroid[1] += CCD['centroid'][1] * CCD['last_reference_star']['sn']
                    denominator += CCD['last_reference_star']['sn']
                    
            if denominator != 0:
                combined_centroid[0] = combined_centroid[0] / denominator
                combined_centroid[1] = combined_centroid[1] / denominator
            
        elif  self.centroid_combination_type == "Median":
            valid_centroids = []
            for CCD in self.CCDs:
                # Only average active CCDs with valid centroids
                if ( (CCD['runtime_active'] == True) and (CCD['valid_centroid'] == True) ):
                    valid_centroids.append(CCD['centroid'])
                combined_centroid = numpy.median(valid_centroids, axis=0)
                
                
        # Combine Seeing & Transparency
        combined_seeing = 0.0
        combined_transparency = 0.0
        n_valid_centroids = 0
        for CCD in self.CCDs:
            # Only average active CCDs with valid centroids - Mean average
            if ( (CCD['runtime_active'] == True) and (CCD['valid_centroid'] == True) ):
                combined_seeing += CCD['last_reference_star']['fwhm_image']
                combined_transparency += CCD['last_reference_star']['flux_auto'] / \
                                         CCD['original_reference_star']['flux_auto']
                n_valid_centroids += 1
        if n_valid_centroids != 0:
            combined_seeing = combined_seeing / n_valid_centroids
            combined_transparency = combined_transparency / n_valid_centroids
        else:
            combined_seeing = 0.0
            combined_transparency = 0.0
        
        # Share Centroid correction
        self.info('Centroid sent [%.5f,%.5f] (pixels)'
                  %(combined_centroid[0], combined_centroid[1]))
        
        # Update centroid("), seeing(") & transparency(%) shared variables to GUI
        # TCS signal ( centroid * feedback * enable[True/False] )
        centroid_arcsec = [combined_centroid[0] * self.scale,
                           combined_centroid[1] * self.scale]
        self.tcs_signal = [combined_centroid[0] * self.scale *
                           (self.feedback_percentage / 100.0) * self.send_corrections,
                           combined_centroid[1] * self.scale *
                           (self.feedback_percentage / 100.0) * self.send_corrections]
        
        centroid_dict = {'measured': centroid_arcsec,
                         'tcssignal': self.tcs_signal}
        self.shared_centroid.write(centroid_dict)
        self.shared_seeing.write(combined_seeing * self.scale)
        self.shared_transparency.write(combined_transparency)
        
        # In simulation mode compute the guiding error
        if self.enable_simulation == True:
            # Correct simulated telescope error
            self.true_offset[0] = self.true_offset[0] + (self.tcs_signal[0] / self.scale)
            self.true_offset[1] = self.true_offset[1] + (self.tcs_signal[1] / self.scale)
            self.debug('Guiding error [%.5f,%.5f] (pixels)'
                  %(self.true_offset[0], self.true_offset[1]))
                  
            # Testing Unit
            self.error_array.append(self.true_offset)
            if self.show_testunit:
                self.test_unit()
        
        # Save sequence statistics
        self.sequence_statistics['x_offset'].append(self.tcs_signal[0] / self.scale)
        self.sequence_statistics['y_offset'].append(self.tcs_signal[1] / self.scale)
        self.sequence_statistics['transparency'].append(combined_transparency)
        self.sequence_statistics['seeing'].append(combined_seeing * self.scale)
        for CCD in self.CCDs:
            if ( (CCD['runtime_active'] == True) and (CCD['valid_centroid'] == True) ):
                self.sequence_statistics['flux'][self.guide_ccds[CCD['id']]].append(CCD['last_reference_star']['flux_auto'])
        
        return combined_centroid
        
    
    def guide_control(self):
        # Check guiding & CCDs status
        self.debug("Started guide control...")
        if not self.enable_guiding.is_set():
            self.debug("Guider not set. Skip guide control.")
            return -1
            
        # Check CCD continuous error
        valid_centroids = 0
        for CCD in self.CCDs:
            if CCD['runtime_active'] == True:
                if CCD['valid_centroid'] == True:
                    valid_centroids += 1
                    CCD['continuous_errors'] = 0
                else:
                    CCD['continuous_errors'] += 1
                    if CCD['continuous_errors'] > self.max_ccd_errors:
                        self.info("[CCD %d] Continuous errors limit exceeded." %CCD['id'])
                        self.warn("[CCD %d] Disabling CCD." %CCD['id'])
                        CCD['runtime_active'] = False
                        self.sequence_statistics['guider_termination'] = 2
        self.debug("Valid centroids: %d" %valid_centroids)
        
        # Check number of null centroids
        if ((valid_centroids == 0) and (self.guide_iteration != 0)):
            self.continuous_null_centroids += 1
            if self.continuous_null_centroids > self.max_null_centroids:
                self.halt_guider("Continuous null centroids limit exceeded." )
                self.sequence_statistics['guider_termination'] = 3
                return -1
        else:
            self.continuous_null_centroids = 0
            
        # Check available CCDs
        active_ccds = 0
        for CCD in self.CCDs:
            if CCD['runtime_active'] == True:
                active_ccds += 1
        self.debug("Active CCDs: %d" %active_ccds)
        if active_ccds == 0:
            self.halt_guider("No active CCDs")
            self.sequence_statistics['guider_termination'] = 3
            return -1
        elif valid_centroids == 0:
            # No valid centroids but still active CCDs
            return 'continue'
        return 0
    
    def halt_guider(self, msg):
        # Disable guiding loop variable
        self.error("Guider halted: " + msg)
        self.alarm_alert(msg, id=2000)
        # Update Guider status for GUI
        self.shared_guiderstatus.write('ERROR')
        self.enable_guiding.clear()
        return 'SUCCESS: ' + self.shared_guiderstatus._value
    
    def compute_sequence_statistics(self):
        self.info("Computing final statistics for exposure header...")
        # Get exposure object for this image
        try:
            exp = Exposure(self.expid, readonly=False)
        except Exception, e:
            rstring = 'Exception in compute_sequence_statistics (Exposure %d): %s ' % (expnum,str(e))
            self.error(rstring)
            return 'FAILED: ' + rstring
        # Guider final status
        summary = {'expid': self.expid}
        exp.guider = self.sequence_statistics['guider_termination'] # Guider 0-absent, 1-ok, 2-lost star, 3-lost all
        summary['guider'] = exp.guider
        # Guider mode
        exp.add_header('G-MODE', str(self.guide_mode), comment = 'Guider operation mode')
        summary['mode'] = str(self.guide_mode)
        # Guider final active CCDs
        final_ccds = 0
        for CCD in self.CCDs:
            if CCD['runtime_active']:
                final_ccds += 1
        exp.add_header('G-CCDNUM', final_ccds, comment = 'Number of guide CCDs that remained active')
        summary['ccdnum'] = final_ccds
        # Guider feedback percentage
        exp.add_header('G-FEEDBK', self.feedback_percentage, comment = '[%] Guider feedback')
        summary['feedback'] = self.feedback_percentage
        
        if(len(self.sequence_statistics['x_offset']) > 0 and len(self.sequence_statistics['y_offset']) > 0):
            # Convert lists to numpy arrays
            numpy_x_offsets = numpy.array(self.sequence_statistics['x_offset'])
            numpy_y_offsets = numpy.array(self.sequence_statistics['y_offset'])
            
            # Guider Centroid offsets first order Means
            x_mean = numpy_x_offsets.mean()
            y_mean = numpy_y_offsets.mean()
            exp.add_header('G-MEANX', round(x_mean,3), comment = '[arcsec] Guider x-axis mean offset')
            exp.add_header('G-MEANY', round(y_mean,3), comment = '[arcsec] Guider y-axis mean offset')
            summary['meanx'] = round(x_mean,3)
            summary['meany'] = round(y_mean,3)
            
            # Guider Centroid offsets second order Means
            x_mean2 = round(numpy_x_offsets.var(),3)
            y_mean2 = round(numpy_y_offsets.var(),3)
            exp.add_header('G-MEANX2',x_mean2, comment = '[arcsec2] Guider (x) 2nd moment mean offset')
            exp.add_header('G-MEANY2',y_mean2, comment = '[arcsec2] Guider (y) 2nd moment mean offset')
            summary['meanx2'] = round(x_mean2,3)
            summary['meany2'] = round(y_mean2,3)
            
            # Guider cross-axis Centroid offset second moment Mean
            cross_moment2_mean = ((numpy_x_offsets - x_mean)*(numpy_y_offsets - y_mean)).mean()
            exp.add_header('G-MEANXY', round(cross_moment2_mean,3), comment = '[arcsec2] Guider (xy) 2nd moment mean offset')
            summary['meanxy'] = round(cross_moment2_mean,3)
            
            # Guider Maximum Centroid offsets
            maxx = round(numpy_x_offsets.max(),3)
            maxy = round(numpy_y_offsets.max(),3)
            exp.add_header('G-MAXX', maxx , comment = '[arcsec] Guider x-axis maximum offset')
            exp.add_header('G-MAXY', maxy , comment = '[arcsec] Guider y-axis maximum offset')
            summary['maxx'] = round(maxx,3)
            summary['maxy'] = round(maxy,3)
            
        if(len(self.sequence_statistics['flux']) > 0):
            # Guider mean variance of guide star fluxes
            flux_variance_array = []
            for CCD in self.CCDs:
                if CCD['runtime_active']:
                    flux_variance_array.append(numpy.array(self.sequence_statistics['flux'][self.guide_ccds[CCD['id']]]).var())
            if(len(flux_variance_array) > 0): ### BUG / TODO FIX: Seems that sometimes flux_variance_array contains something other than a double
                test = round(numpy.array(flux_variance_array).mean(),3)
                try:
                    v = float(test)
                    if type(v) is float:
                        if math.isnan(v):
                            v = 'NaN'
                    exp.add_header('G-FLXVAR',v,
                                   comment = '[arcsec] Guider mean guide star flux variances')
                    summary['fluxvar'] = v
                except:
                    self.error("Error trying to write invalid value into fits header!") 
        
        if(len(self.sequence_statistics['transparency']) > 0):
            # Guider mean transparency
            numpy_transparency = numpy.array(self.sequence_statistics['transparency'])
            exp.add_header('G-TRANSP', round(numpy_transparency.mean(),3), comment = 'Guider average sky transparency')
            summary['transparency'] = round(numpy_transparency.mean(),3)
            
        if(len(self.sequence_statistics['seeing']) > 0):
            # Guider mean seeings
            numpy_seeing = numpy.array(self.sequence_statistics['seeing'])
            exp.add_header('G-SEEING', round(numpy_seeing.mean(),3), comment = '[arcsec] Guider average seeing')
            summary['seeing'] = round(numpy_seeing.mean(),3)
            
        if(len(self.sequence_statistics['latency']) > 0):
            # Guider mean latency
            numpy_latency = numpy.array(self.sequence_statistics['latency'])
            exp.add_header('G-LATENC', round(numpy_latency.mean(),3), comment = '[s] Guider avg. latency between exposures')
            summary['latency'] = round(numpy_latency.mean(),3)

        if summary != {}:
            # Update summary SV
            summary['time_recorded'] = datetime.datetime.utcnow().isoformat().replace('T', ' ')
            self.summarySV.write(summary)
            
        self.info("Header statistics completed.")
    
    # SIMULATION Methods
    def test_unit(self):
        # Testing Unit
        print  "\n############# TEST UNIT #############"
        print "Number of iterations to measure: %d" %self.guide_iteration
        numpy_array = numpy.array(self.error_array)
        #XY (RA,DEC)
        print "MEAN error in X: %.5f   Y: %.5f" %(numpy_array.mean(0)[0],
                                                 numpy_array.mean(0)[1])
        print "STD  error in X: %.5f   Y: %.5f" %(numpy_array.std(0)[0],
                                                 numpy_array.std(0)[1])
        # Euclidean
        euclidean = numpy.hypot(numpy_array.transpose()[0],
                                numpy_array.transpose()[1])
        print "Euclidean MEAN error: %.5f" %euclidean.mean()
        print "Euclidean STD  error: %.5f" %euclidean.std()
        print "#####################################\n\n"
    
    def simulate_guide_image(self,CCD):
        # Request first image acquisition
        iCCD = CCD['id']
        sim_done_path = os.path.join(self.tmp_directory, "decam-guide_ccd%d.DONE" %iCCD)
        if os.path.exists(sim_done_path):
            os.remove(sim_done_path) # Remove DONE
        
        # Single CCD Image Simulation
        self.debug("[CCD %d] Image simulation threaded."%iCCD)
        try:
            # All random ROIs
            if self.guide_mode == 'auto':
                roi_radius = self.roi_radius
                roi_center = [-1,-1]
            # All Full images 
            elif self.guide_mode in ['self', 'user']:
                roi_radius = 0
                roi_center = [0,0]
            # ROIs from a given zone in the image (Not Available in this version)
            else:
                roi_radius = self.roi_radius
                roi_center = [ int( CCD['original_reference_star']['x_image'] ),
                               int( CCD['original_reference_star']['y_image'] ) ]
            thread_cmd = ( "simulate_c " + os.path.join(self.product_path, "config/sim.params") +
                        " %d %d %d %d %d %d %d %f %f %s" %(self.ccd_size[0],
                                                           self.ccd_size[1],
                                                           self.guide_iteration,
                                                           roi_radius,
                                                           roi_center[0],
                                                           roi_center[1],
                                                           iCCD,
                                                           self.true_offset[0],
                                                           self.true_offset[1],
                                                           self.working_directory ))
            sim_thread=threading.Thread(target = self.thread_os_cmd, name = "simulate_image", args = (thread_cmd,))
            sim_thread.start()
        except:
            # Stop guiding & exit
            self.halt_guider("[CCD %d] Guide Image Simulation error." %iCCD)
            return -1
        
        # Wait for .DONE file
        self.debug("[CCD %d] Waiting for .DONE file..." %iCCD)
        loop_time_start = time.time()
        while ( not os.path.exists( sim_done_path ) ):
            # Check waiting time
            loop_time_elapsed = time.time() - loop_time_start
            if loop_time_elapsed > self.config['max_wait_time']:
                # Stop guiding & exit
                self.halt_guider("[CCD %d] Wait time for simulated .DONE file exceeded." %iCCD)
                return -1
            # Stop waiting if stop guider is requested
            if not self.enable_guiding.is_set():
                return -1
            time.sleep(0.1)
        os.remove(sim_done_path) # Remove simulated DONE
        try:
            os.remove( os.path.join(self.tmp_directory, 'sim-usedvalues.params') )  # Remove sim-usedvalues
        except:
            # Other thread already erased it
            pass
        self.debug("[CCD %d] ...guide image found!" %iCCD)
        
        # Image path+file name
        image_path = sim_done_path.replace('.DONE','.fits')
        
        # >>> Update CCD
        CCD['sim_image_path'] = image_path
        return CCD
    
    def simulate_guide_array(self, image_name):
        self.debug("Simulating Guide Postage stamps...")
        self.add_telescope_error()
        # Launch simulation threads
        th_array = []
        for CCD in self.CCDs:
            if CCD['runtime_active'] == True:
                ccd_th = threading.Thread(target=self.simulate_guide_image, args=(CCD, ))
                ccd_th.start()
                th_array.append(ccd_th)
            
        # Wait for CCD threads completion
        for ccd_th in th_array:
            ccd_th.join()
        
        # Build the Fits multi extension
        import pyfits
        # Initialize the fits array
        self.debug("Replacing Panview's Guider Stamps with Simulated data...")
        fits_array_path = os.path.join(self.image_directory, image_name)
        if os.path.exists(fits_array_path):
            os.remove(fits_array_path)
        pyfits.writeto(fits_array_path,
                       data = numpy.array([], dtype = 'uint8'),
                       header = pyfits.Header(),
                       clobber = 'True')
        # Append Guide CCDs
        for CCD in self.CCDs:
            if CCD['runtime_active'] == True:
                try:
                    ccd_hdu = pyfits.open(CCD['sim_image_path'])
                    pyfits.append(fits_array_path, ccd_hdu[0].data, ccd_hdu[0].header)
                except Exception, msg:
                    self.warn('Unable to open ccd file: %s' % msg)
                    pyfits.append(fits_array_path, numpy.zeros([5,5], dtype = 'uint8'))
            else:
                pyfits.append(fits_array_path, numpy.zeros([5,5], dtype = 'uint8'))
        self.debug("Guide Image Simulation bypass completed.")
        # Generate .DONE file for array - Disabled because Panview creates his own .DONE file
        #open(fits_array_path[:-5] + '.DONE', 'w').close() 
    
    def add_telescope_error(self):
        # Simulates telescope gaussian error (for Simulation mode only)
        if self.guide_iteration == 0:
            # No error for the first iteration
            self.true_offset = [0.0, 0.0]
        else:
            # Error is added to previous correction
            self.true_offset = [random.gauss(self.true_offset[0],self.config['turbulence_sigma']/self.config['scale']),
                                random.gauss(self.true_offset[1],self.config['turbulence_sigma']/self.config['scale'])]
            self.debug('New simulated telescope offset is [%.5f, %.5f] (pixels)' %(self.true_offset[0],
                                                                                   self.true_offset[1]))
        return 0
######################################################################            
    
    def thread_os_cmd(self, in_cmd):
        os.system(in_cmd)
    

if __name__ == "__main__":
    Guider().run()

